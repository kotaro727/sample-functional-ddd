# スマートコンストラクタパターンについて

## 概要

**スマートコンストラクタ（Smart Constructor）**は、オブジェクトの生成時にバリデーションを行い、不正な状態のオブジェクトが作成されることを防ぐデザインパターンです。

関数型プログラミングとドメイン駆動設計（DDD）において、値オブジェクト（Value Object）を安全に生成するために広く使われています。

## 問題：普通のコンストラクタの課題

### 通常のオブジェクト生成の問題点

```typescript
// 問題のあるアプローチ
type Price = {
  value: number;
};

// 直接オブジェクトを作成できてしまう
const price1: Price = { value: 100 };    // OK
const price2: Price = { value: -50 };    // 不正だが作成できてしまう！
const price3: Price = { value: NaN };    // 不正だが作成できてしまう！

// ビジネスロジックで毎回バリデーションが必要
function calculateTotal(price: Price, quantity: number): number {
  if (price.value < 0) {  // 毎回チェックが必要
    throw new Error('負の価格です');
  }
  return price.value * quantity;
}
```

**問題点:**
1. **不正な状態の作成を防げない**: 負の価格やNaNが作成できてしまう
2. **バリデーションの重複**: 使用する側で毎回チェックが必要
3. **型では保証されない**: TypeScriptの型システムでは「正の数」を表現できない
4. **ドメインルールの分散**: バリデーションロジックがあちこちに散らばる

## 解決策：スマートコンストラクタパターン

### 基本的な実装

```typescript
import { Result, ok, err } from '@shared/functional/result';

// 1. 型定義（外部から直接作成できないようにする）
export type Price = Readonly<{
  _brand: 'Price';  // ブランド型で区別
  value: number;
}>;

// 2. バリデーションエラーの定義
export type PriceError = {
  type: 'NEGATIVE_PRICE';
  message: '価格は0以上である必要があります';
};

// 3. スマートコンストラクタ（唯一の生成手段）
export const createPrice = (value: number): Result<Price, PriceError> => {
  // バリデーション
  if (value < 0) {
    return err({
      type: 'NEGATIVE_PRICE',
      message: '価格は0以上である必要があります',
    });
  }

  // 有効な値の場合のみ作成
  return ok({ _brand: 'Price', value } as Price);
};

// 4. 値へのアクセサ
export const getValue = (price: Price): number => price.value;
```

### 使用例

```typescript
// スマートコンストラクタ経由でのみ作成可能
const priceResult1 = createPrice(100);   // ok({ _brand: 'Price', value: 100 })
const priceResult2 = createPrice(-50);   // err({ type: 'NEGATIVE_PRICE', ... })

// 直接作成しようとしても型エラー
// const price: Price = { _brand: 'Price', value: -50 };  // 型エラー！

// 使用側はバリデーション不要
function calculateTotal(price: Price, quantity: number): number {
  // priceは必ず有効な値を持つことが保証されている
  return getValue(price) * quantity;  // バリデーション不要！
}

// Result型でエラーハンドリング
if (isOk(priceResult1)) {
  const total = calculateTotal(priceResult1.value, 5);
  console.log(total);  // 500
}
```

## パターンの構成要素

### 1. ブランド型（Brand Type）

```typescript
export type Price = Readonly<{
  _brand: 'Price';  // ← ブランド型
  value: number;
}>;

export type ProductId = Readonly<{
  _brand: 'ProductId';  // ← 別のブランド
  value: number;
}>;
```

**目的:**
- 同じプリミティブ型でも異なる型として扱う
- 誤った代入を防ぐ

**効果:**

```typescript
const price = createPrice(100);
const productId = createProductId(100);

// 両方とも number を持つが、型が異なるため代入できない
// const id: ProductId = price;  // 型エラー！
```

### 2. Readonly修飾子

```typescript
export type Price = Readonly<{
  _brand: 'Price';
  value: number;
}>;
```

**目的:**
- イミュータビリティ（不変性）を保証
- 値オブジェクトの原則を守る

**効果:**

```typescript
const priceResult = createPrice(100);
if (isOk(priceResult)) {
  const price = priceResult.value;
  // price.value = 200;  // 型エラー！readonlyなので変更不可
}
```

### 3. スマートコンストラクタ関数

```typescript
export const createPrice = (value: number): Result<Price, PriceError> => {
  // バリデーション
  if (value < 0) {
    return err({ type: 'NEGATIVE_PRICE', message: '...' });
  }

  // 有効な値のみ作成
  return ok({ _brand: 'Price', value } as Price);
};
```

**特徴:**
- バリデーションを内包
- Result型で成功/失敗を表現
- 外部から直接オブジェクトを作成できない

### 4. アクセサ関数

```typescript
export const getValue = (price: Price): number => price.value;
export const equals = (a: Price, b: Price): boolean => a.value === b.value;
```

**目的:**
- カプセル化
- 内部実装の隠蔽

## このプロジェクトでの実装例

### 例1: Price値オブジェクト

`src/domain/product/valueObjects/price.ts`:

```typescript
import { Result, ok, err } from '@shared/functional/result';

export type Price = Readonly<{
  _brand: 'Price';
  value: number;
}>;

export type PriceError = {
  type: 'NEGATIVE_PRICE';
  message: '価格は0以上である必要があります';
};

// スマートコンストラクタ
export const createPrice = (value: number): Result<Price, PriceError> => {
  if (value < 0) {
    return err({
      type: 'NEGATIVE_PRICE',
      message: '価格は0以上である必要があります',
    });
  }
  return ok({ _brand: 'Price', value } as Price);
};

export const getValue = (price: Price): number => price.value;
export const equals = (a: Price, b: Price): boolean => a.value === b.value;
```

### 例2: ProductId値オブジェクト

`src/domain/product/valueObjects/productId.ts`:

```typescript
export type ProductId = Readonly<{
  _brand: 'ProductId';
  value: number;
}>;

export type ProductIdError = {
  type: 'INVALID_ID';
  message: 'ProductIdは正の整数である必要があります';
};

// スマートコンストラクタ
export const createProductId = (value: number): Result<ProductId, ProductIdError> => {
  // 正の整数チェック
  if (value <= 0 || !Number.isInteger(value)) {
    return err({
      type: 'INVALID_ID',
      message: 'ProductIdは正の整数である必要があります',
    });
  }
  return ok({ _brand: 'ProductId', value } as ProductId);
};

export const getValue = (id: ProductId): number => id.value;
export const equals = (a: ProductId, b: ProductId): boolean => a.value === b.value;
```

### 例3: Email値オブジェクト

`src/domain/shared/valueObjects/email.ts`:

```typescript
export type Email = Readonly<{
  _brand: 'Email';
  value: string;
}>;

export type EmailError =
  | { type: 'EMPTY'; message: 'メールアドレスが空です' }
  | { type: 'INVALID_FORMAT'; message: 'メールアドレスの形式が不正です' };

const EMAIL_PATTERN = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;

// スマートコンストラクタ
export const createEmail = (value: string): Result<Email, EmailError> => {
  // 空文字チェック
  if (value.trim() === '') {
    return err({ type: 'EMPTY', message: 'メールアドレスが空です' });
  }

  // フォーマットチェック
  if (!EMAIL_PATTERN.test(value)) {
    return err({ type: 'INVALID_FORMAT', message: 'メールアドレスの形式が不正です' });
  }

  return ok({ _brand: 'Email', value } as Email);
};

export const getValue = (email: Email): string => email.value;
export const equals = (a: Email, b: Email): boolean => a.value === b.value;
```

### 例4: Product集約

`src/domain/product/product.ts`:

```typescript
export type Product = Readonly<{
  id: ProductId;
  title: string;
  price: Price;
  description: string;
}>;

export type ProductError =
  | ProductIdError
  | PriceError
  | { type: 'EMPTY_TITLE'; message: 'タイトルは必須です' };

// スマートコンストラクタ（集約全体）
export const createProduct = (input: ProductInput): Result<Product, ProductError> => {
  // タイトルのバリデーション
  if (input.title.trim() === '') {
    return err({ type: 'EMPTY_TITLE', message: 'タイトルは必須です' });
  }

  // 値オブジェクトの作成（それぞれがスマートコンストラクタ）
  const productIdResult = createProductId(input.id);
  const priceResult = createPrice(input.price);

  // 複数のスマートコンストラクタの結果を合成
  return pipe(
    productIdResult,
    flatMap((id) =>
      pipe(
        priceResult,
        map((price) => ({
          id,
          title: input.title,
          price,
          description: input.description,
        }))
      )
    )
  );
};
```

## スマートコンストラクタの利点

### 1. 不正な状態の防止

```typescript
// 直接作成はできない
// const price: Price = { _brand: 'Price', value: -100 };  // 型エラー

// スマートコンストラクタを通す必要がある
const priceResult = createPrice(-100);
// err({ type: 'NEGATIVE_PRICE', ... })

// 有効な Price 型の値は必ず正しい状態
```

### 2. バリデーションの一元化

```typescript
// バリデーションはスマートコンストラクタに集約
export const createPrice = (value: number): Result<Price, PriceError> => {
  if (value < 0) {
    return err({ type: 'NEGATIVE_PRICE', message: '...' });
  }
  return ok({ _brand: 'Price', value } as Price);
};

// 使用側はバリデーション不要
function processPrice(price: Price) {
  // price は必ず有効な値を持つ
  const value = getValue(price);
  // バリデーション不要！
}
```

### 3. 型の明確な区別

```typescript
// 同じプリミティブ型でも異なる型として扱える
const price = createPrice(100);
const productId = createProductId(100);
const userId = createUserId(100);

// 誤った代入を型システムが防ぐ
function setProductId(id: ProductId) { }

// setProductId(price);    // 型エラー！
// setProductId(userId);   // 型エラー！
```

### 4. ドメインルールの表現

```typescript
// ドメインルールが型とバリデーションで表現される
export const createAge = (value: number): Result<Age, AgeError> => {
  if (value < 0 || value > 150) {
    return err({ type: 'OUT_OF_RANGE', message: '年齢は0-150の範囲です' });
  }
  if (!Number.isInteger(value)) {
    return err({ type: 'NOT_INTEGER', message: '年齢は整数である必要があります' });
  }
  return ok({ _brand: 'Age', value } as Age);
};

// Age型を持つ値は必ずドメインルールを満たす
```

### 5. リファクタリングの安全性

```typescript
// 値オブジェクトの内部実装を変更しても
// 外部への影響を最小限にできる

// Before
export type Price = Readonly<{
  _brand: 'Price';
  value: number;
}>;

// After: 通貨を追加
export type Price = Readonly<{
  _brand: 'Price';
  value: number;
  currency: string;  // 追加
}>;

// スマートコンストラクタとアクセサを更新すれば、
// 外部コードへの影響は少ない
```

## Result型との組み合わせ

### エラーハンドリングの統一

```typescript
// スマートコンストラクタは Result 型を返す
const emailResult = createEmail('invalid');

// Result型の標準的な操作が使える
if (isOk(emailResult)) {
  const email = emailResult.value;
  sendEmail(email);
} else {
  console.error(emailResult.error.message);
}
```

### pipeでの合成

```typescript
// 複数のスマートコンストラクタを合成
const createUser = (input: UserInput): Result<User, ValidationError> =>
  pipe(
    createEmail(input.email),
    flatMap((email) =>
      pipe(
        createAge(input.age),
        map((age) => ({ email, age, name: input.name }))
      )
    )
  );

// エラーは自動的に伝播
const userResult = createUser({
  email: 'invalid',
  age: 25,
  name: 'Taro'
});
// err({ type: 'INVALID_FORMAT', ... })
```

## テストでの使用

### 値オブジェクトのテスト

```typescript
import { describe, test, expect } from 'bun:test';
import { createPrice } from './price';
import { isOk, isErr } from '@shared/functional/result';

describe('Price値オブジェクト', () => {
  describe('createPrice', () => {
    test('正の数で成功', () => {
      const result = createPrice(100);
      expect(isOk(result)).toBe(true);
      if (isOk(result)) {
        expect(getValue(result.value)).toBe(100);
      }
    });

    test('0で成功', () => {
      const result = createPrice(0);
      expect(isOk(result)).toBe(true);
    });

    test('負の数で失敗', () => {
      const result = createPrice(-1);
      expect(isErr(result)).toBe(true);
      if (isErr(result)) {
        expect(result.error.type).toBe('NEGATIVE_PRICE');
      }
    });
  });
});
```

### テストデータの作成

```typescript
// テストでは有効な値を簡単に作成できる
const createTestPrice = (value: number = 100): Price => {
  const result = createPrice(value);
  if (isOk(result)) {
    return result.value;
  }
  throw new Error(`テストデータの作成に失敗: ${value}`);
};

// テストで使用
test('合計金額を計算', () => {
  const price = createTestPrice(100);
  const total = calculateTotal(price, 3);
  expect(total).toBe(300);
});
```

## 実践的なパターン

### パターン1: 複数のバリデーション

```typescript
export const createUsername = (value: string): Result<Username, UsernameError> => {
  // 空文字チェック
  if (value.trim() === '') {
    return err({ type: 'EMPTY', message: 'ユーザー名は必須です' });
  }

  // 長さチェック
  if (value.length < 3 || value.length > 20) {
    return err({ type: 'INVALID_LENGTH', message: '3-20文字である必要があります' });
  }

  // 文字種チェック
  if (!/^[a-zA-Z0-9_]+$/.test(value)) {
    return err({ type: 'INVALID_CHARS', message: '英数字とアンダースコアのみ使用可能です' });
  }

  return ok({ _brand: 'Username', value } as Username);
};
```

### パターン2: ドメイン固有のバリデーション

```typescript
// 営業日のみを表現する値オブジェクト
export const createBusinessDay = (date: Date): Result<BusinessDay, BusinessDayError> => {
  // 土日チェック
  const dayOfWeek = date.getDay();
  if (dayOfWeek === 0 || dayOfWeek === 6) {
    return err({ type: 'WEEKEND', message: '営業日ではありません（土日）' });
  }

  // 祝日チェック（簡略版）
  if (isHoliday(date)) {
    return err({ type: 'HOLIDAY', message: '営業日ではありません（祝日）' });
  }

  return ok({ _brand: 'BusinessDay', value: date } as BusinessDay);
};
```

### パターン3: 値の正規化

```typescript
// 入力値を正規化してから保存
export const createEmail = (value: string): Result<Email, EmailError> => {
  // トリム + 小文字化
  const normalized = value.trim().toLowerCase();

  if (normalized === '') {
    return err({ type: 'EMPTY', message: 'メールアドレスが空です' });
  }

  if (!EMAIL_PATTERN.test(normalized)) {
    return err({ type: 'INVALID_FORMAT', message: 'メールアドレスの形式が不正です' });
  }

  // 正規化された値を保存
  return ok({ _brand: 'Email', value: normalized } as Email);
};
```

### パターン4: 依存バリデーション

```typescript
// 開始日と終了日の関係をチェック
export const createDateRange = (
  start: Date,
  end: Date
): Result<DateRange, DateRangeError> => {
  if (start > end) {
    return err({ type: 'INVALID_RANGE', message: '開始日は終了日より前である必要があります' });
  }

  const diffDays = (end.getTime() - start.getTime()) / (1000 * 60 * 60 * 24);
  if (diffDays > 365) {
    return err({ type: 'TOO_LONG', message: '期間は365日以内である必要があります' });
  }

  return ok({ _brand: 'DateRange', start, end } as DateRange);
};
```

### パターン5: 変換を伴う生成

```typescript
// 文字列から数値への変換を伴う
export const createQuantity = (input: string): Result<Quantity, QuantityError> => {
  const value = Number.parseInt(input, 10);

  if (Number.isNaN(value)) {
    return err({ type: 'NOT_A_NUMBER', message: '数値ではありません' });
  }

  if (value <= 0) {
    return err({ type: 'NOT_POSITIVE', message: '正の整数である必要があります' });
  }

  return ok({ _brand: 'Quantity', value } as Quantity);
};
```

## ベストプラクティス

### 1. 常にスマートコンストラクタ経由で作成

```typescript
// Good: スマートコンストラクタを使用
const priceResult = createPrice(100);

// Bad: 直接オブジェクトを作成（型エラーになるべき）
// const price: Price = { _brand: 'Price', value: 100 };
```

### 2. バリデーションエラーは具体的に

```typescript
// Good: 具体的なエラー型
export type EmailError =
  | { type: 'EMPTY'; message: 'メールアドレスが空です' }
  | { type: 'INVALID_FORMAT'; message: 'メールアドレスの形式が不正です' }
  | { type: 'DOMAIN_NOT_ALLOWED'; domain: string; message: string };

// Bad: 汎用的すぎる
export type EmailError = string;
```

### 3. アクセサ関数を提供

```typescript
// Good: アクセサ関数でカプセル化
export const getValue = (price: Price): number => price.value;

// Bad: 直接アクセス
// const value = price.value;  // できてしまうが、推奨しない
```

### 4. イミュータビリティを保つ

```typescript
// Good: Readonlyで不変性を保証
export type Price = Readonly<{
  _brand: 'Price';
  value: number;
}>;

// Bad: 変更可能
export type Price = {
  _brand: 'Price';
  value: number;
};
```

### 5. ブランド型で区別

```typescript
// Good: 異なる型として区別
export type Price = Readonly<{ _brand: 'Price'; value: number }>;
export type Quantity = Readonly<{ _brand: 'Quantity'; value: number }>;

// Bad: 同じ型として扱われる
export type Price = number;
export type Quantity = number;
```

## よくある質問

### Q1: なぜ `as Price` でキャストが必要なのか？

A: ブランド型の `_brand` プロパティは型レベルでのみ存在し、実行時には存在しないためです。

```typescript
// _brand は型レベルの概念
export type Price = Readonly<{
  _brand: 'Price';  // 実行時には存在しない
  value: number;
}>;

// キャストが必要
return ok({ _brand: 'Price', value } as Price);

// キャストなしだと型エラー
// return ok({ _brand: 'Price', value });  // 型エラー
```

### Q2: クラスではなく関数を使う理由は？

A: 関数型プログラミングのアプローチに従い、イミュータブルなデータ構造と純粋関数を使うためです。

```typescript
// 関数型アプローチ（推奨）
export const createPrice = (value: number): Result<Price, PriceError> => {
  // ...
};

// オブジェクト指向アプローチ
class Price {
  constructor(private value: number) {
    if (value < 0) throw new Error('...');
  }
}
```

関数型アプローチの利点:
- テストしやすい
- 関数合成が容易
- `this` の扱いが不要
- Result型との相性が良い

### Q3: すべての値にスマートコンストラクタが必要？

A: いいえ。ドメインルールがある値のみに適用します。

```typescript
// 必要: ドメインルールがある
const price = createPrice(100);        // 非負である必要がある
const email = createEmail('...');      // フォーマットチェックが必要

// 不要: 単なるデータ
type User = {
  name: string;        // 単なる文字列
  registeredAt: Date;  // 単なる日付
};
```

## まとめ

スマートコンストラクタパターンにより:

1. **不正な状態の防止**: バリデーションに合格した値のみが作成される
2. **型安全性の向上**: ブランド型により異なる概念を区別できる
3. **バリデーションの一元化**: ドメインルールが1箇所に集約される
4. **イミュータビリティ**: Readonlyにより不変性が保証される
5. **Result型との統合**: 関数型エラーハンドリングと自然に結合
6. **テスタビリティ**: 純粋関数なのでテストが容易
7. **リファクタリングの安全性**: 内部実装の変更が外部に影響しにくい

このプロジェクトでは、値オブジェクトと集約の両方にスマートコンストラクタパターンを適用することで、**型安全で堅牢なドメインモデル**を実現しています。

## 関連項目

- [Result型について.md](./Result型について.md) - Result型との統合
- [Pipe関数について.md](./Pipe関数について.md) - スマートコンストラクタの合成
- `src/domain/product/valueObjects/` - 値オブジェクトの実装例
- `src/domain/shared/valueObjects/` - 共有値オブジェクト
- `CLAUDE.md` - プロジェクト全体のドメイン駆動設計方針
