# 集約（Aggregate）

## 集約とは

集約とは、トップレベルのエンティティが「ルート」として機能する、単一のユニットとして扱えるドメインオブジェクトのコレクションです。

集約内のオブジェクトに対するすべての変更は、集約ルートであるトップレベルエンティティを起点にする必要があり、集約は、集約内のすべてのデータが同時に正しく更新されることを保証する整合性の境界として機能します。

集約は、永続化、データベーストランザクション、およびデータ転送におけるアトミックな（すべて実行されるか、何も実行されないかのどちらかになる）処理単位です。

## 集約の役割

### 1. 整合性の境界
集約内のすべてのデータが同時に正しく更新されることを保証します。ビジネスルール（不変条件）は集約の境界内で常に守られます。

**例:**
```typescript
// 注文集約は「注文合計金額 = 各明細の合計」という不変条件を保証
export type Order = {
  readonly _tag: 'Order';
  readonly customerId: CustomerId;
  readonly items: readonly OrderItem[];
  readonly totalAmount: Money;  // 常に items の合計と一致
  readonly status: OrderStatus;
};
```

### 2. トランザクション境界
永続化における原子的な処理単位として機能します。1つの集約 = 1つのトランザクションが基本です。

**原則:**
- 1つのトランザクションで1つの集約のみを変更
- 複数の集約を変更する場合は、結果整合性またはドメインイベントを使用

### 3. 変更の起点
集約内のオブジェクトへの変更は、必ず集約ルートを経由します。外部から集約内の子オブジェクトを直接変更することは許可されません。

## 集約の設計原則

### 1. 小さく保つ
集約は必要最小限のオブジェクトのみを含めます。大きすぎる集約は以下の問題を引き起こします:
- パフォーマンスの低下
- トランザクション競合の増加
- 複雑性の増大

**良い例:**
```typescript
// 注文集約: 注文に直接関連するもののみ
export type Order = {
  readonly _tag: 'Order';
  readonly customerId: CustomerId;  // IDのみ参照
  readonly items: readonly OrderItem[];
  readonly status: OrderStatus;
};
```

**悪い例:**
```typescript
// 注文集約に顧客情報全体を含める（大きすぎる）
export type Order = {
  readonly _tag: 'Order';
  readonly customer: Customer;  // 集約全体を含める
  readonly items: readonly OrderItem[];
  readonly status: OrderStatus;
};
```

### 2. IDで他の集約を参照
集約間は、オブジェクト参照ではなくIDで参照します。

**良い例:**
```typescript
export type Order = {
  readonly _tag: 'Order';
  readonly customerId: CustomerId;  // IDで参照
  readonly productIds: readonly ProductId[];  // IDで参照
};
```

### 3. 集約ルートのみを外部公開
集約内の子オブジェクトは外部から直接アクセスできないようにします。

## 関数型プログラミングにおける集約

関数型プログラミングでは、集約の操作は純粋関数として実装します。

### 基本パターン

```typescript
// 集約ルート
export type Order = {
  readonly _tag: 'Order';
  readonly customerId: CustomerId;
  readonly items: readonly OrderItem[];
  readonly status: OrderStatus;
};

// 集約ルートを通じた操作（純粋関数）
export const addOrderItem = (
  order: Order,
  item: OrderItem
): Result<Order, DomainError> => {
  // 整合性チェック
  if (order.status === 'Confirmed') {
    return err({
      type: 'ORDER_ALREADY_CONFIRMED',
      message: '確定済みの注文には追加できません',
    });
  }

  // 新しい集約を返す（イミュータブル）
  return ok({
    ...order,
    items: [...order.items, item],
  });
};

// 複数の操作を組み合わせる
export const addItemAndConfirm = (
  order: Order,
  item: OrderItem
): Result<Order, DomainError> => {
  const orderWithItem = addOrderItem(order, item);
  if (isErr(orderWithItem)) return orderWithItem;

  return confirmOrder(orderWithItem.value);
};
```

### 集約の整合性チェック

```typescript
// 不変条件のチェック（純粋関数）
export const validateOrderInvariants = (
  order: Order
): Result<Order, ValidationError> => {
  // 1. 明細が空でないこと
  if (order.items.length === 0) {
    return err({
      type: 'ORDER_ITEMS_EMPTY',
      message: '注文には少なくとも1つの商品が必要です',
    });
  }

  // 2. 合計金額が正しいこと
  const calculatedTotal = order.items.reduce(
    (sum, item) => sum + item.price * item.quantity,
    0
  );
  if (calculatedTotal !== order.totalAmount.value) {
    return err({
      type: 'TOTAL_AMOUNT_MISMATCH',
      message: '合計金額が一致しません',
    });
  }

  return ok(order);
};
```

## このプロジェクトの集約

### Order（注文集約）
- **集約ルート**: Order
- **含まれるオブジェクト**: OrderItem（注文明細）
- **責務**: 注文の整合性を保証（明細の合計、ステータス遷移など）

### Customer（顧客集約）
- **集約ルート**: Customer
- **含まれるオブジェクト**: ValidatedUserProfile（プロフィール）
- **責務**: 顧客情報の整合性を保証

### Product（商品集約）
- **集約ルート**: Product
- **含まれるオブジェクト**: 商品の基本情報
- **責務**: 商品情報の整合性を保証

## よくある間違い

### ❌ 集約が大きすぎる
```typescript
// 悪い例: 注文集約に関連するすべてを含める
export type Order = {
  readonly customer: Customer;  // 顧客集約全体
  readonly items: readonly {
    product: Product;  // 商品集約全体
    quantity: number;
  }[];
  readonly shipment: Shipment;  // 配送集約全体
};
```

### ❌ 集約を跨いだトランザクション
```typescript
// 悪い例: 複数の集約を同時に変更
export const placeOrder = async (
  order: Order,
  customer: Customer
): Promise<void> => {
  // 2つの集約を1つのトランザクションで変更
  await db.transaction(async (tx) => {
    await tx.order.create(order);
    await tx.customer.update(customer);  // NG
  });
};
```

### ✅ 正しいアプローチ
```typescript
// 良い例: イベントを使った結果整合性
export const placeOrder = async (
  order: Order
): Promise<Result<OrderId, DomainError>> => {
  // 1. 注文集約のみを保存
  const orderId = await orderRepository.save(order);

  // 2. ドメインイベントを発行
  await eventBus.publish({
    type: 'OrderPlaced',
    orderId,
    customerId: order.customerId,
  });

  // 3. イベントハンドラーで顧客集約を更新（別トランザクション）
  return ok(orderId);
};
```

## まとめ

集約は、DDDにおける整合性とトランザクションの境界を定義する重要な概念です。

**重要なポイント:**
1. 集約ルートを唯一のエントリーポイントとする
2. 集約内の整合性を常に保証する
3. 1トランザクション = 1集約を原則とする
4. 集約は小さく保つ
5. 集約間はIDで参照する

関数型プログラミングでは、集約の操作を純粋関数として実装し、イミュータブルなデータ構造を使用することで、これらの原則をより明確に表現できます。
