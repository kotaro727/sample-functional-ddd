# イベント駆動アーキテクチャのセットアップ例

## 1. APIサーバーでの設定例

```typescript
// src/presentation/api/server.ts

import { Hono } from 'hono';
import { InMemoryEventBus } from '@infrastructure/events/inMemoryEventBus';
import { ConsoleEmailService } from '@infrastructure/external/consoleEmailService';
import { sendOrderConfirmationEmail } from '@application/order/sendOrderConfirmationEmail';
import { createOrder } from '@application/order/createOrder';
import { InMemoryOrderRepository } from '@infrastructure/memory/inMemoryOrderRepository';
import { DummyJsonProductRepository } from '@infrastructure/external/dummyJsonProductRepository';

// アプリケーション起動時の初期化
export function setupApplication() {
  // 1. インフラストラクチャ層のサービスを作成
  const eventBus = new InMemoryEventBus();
  const emailService = new ConsoleEmailService();
  const orderRepository = new InMemoryOrderRepository();
  const productRepository = new DummyJsonProductRepository();

  // 2. イベントハンドラーを登録
  eventBus.subscribe('ORDER_CREATED', sendOrderConfirmationEmail(emailService));

  // 3. ユースケースを作成
  const createOrderUseCase = createOrder(
    orderRepository,
    productRepository,
    eventBus
  );

  return {
    createOrderUseCase,
    orderRepository,
    productRepository,
  };
}

// Honoアプリケーション
const app = new Hono();

// 依存性を初期化
const { createOrderUseCase } = setupApplication();

// APIエンドポイント
app.post('/api/orders', async (c) => {
  const body = await c.req.json();

  const result = await createOrderUseCase({
    orderItems: body.orderItems,
    shippingAddress: body.shippingAddress,
    customerInfo: body.customerInfo,
  });

  if (result._tag === 'Ok') {
    return c.json(result.value, 201);
  } else {
    return c.json({ error: result.error }, 400);
  }
});

export default app;
```

## 2. テスト環境での使用例

```typescript
// テストでは、モックのEventBusを使用可能
import { describe, test, expect } from 'bun:test';

describe('注文作成の統合テスト', () => {
  test('注文作成時にメールが送信される', async () => {
    // モックEventBusでイベントをキャプチャ
    let capturedEvent = null;
    const mockEventBus = {
      publish: async (event) => {
        capturedEvent = event;
      },
      subscribe: () => {},
    };

    const useCase = createOrder(
      orderRepository,
      productRepository,
      mockEventBus
    );

    await useCase({ /* 注文データ */ });

    // イベントが発行されたことを検証
    expect(capturedEvent).not.toBeNull();
    expect(capturedEvent.type).toBe('ORDER_CREATED');
  });
});
```

## 3. イベントの実行フロー

```
┌─────────────────────────────────────────────────────────────┐
│ 1. クライアントが POST /api/orders にリクエスト             │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. createOrderUseCase が実行される                          │
│    - バリデーション                                          │
│    - ビジネスロジック                                        │
│    - DB保存                                                  │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. eventBus.publish(OrderCreatedEvent) が呼ばれる           │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 登録された全てのハンドラーが並列実行される               │
│    - sendOrderConfirmationEmail                              │
│    - decreaseInventory（将来的に追加可能）                   │
│    - addPoints（将来的に追加可能）                           │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 5. メール送信（ConsoleEmailService）                        │
│    コンソールに出力:                                         │
│    === メール送信 ===                                        │
│    To: yamada@example.com                                    │
│    Subject: 【注文確認】ご注文ありがとうございます          │
│    ...                                                       │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. クライアントに注文結果を返す                             │
└─────────────────────────────────────────────────────────────┘
```

## 4. 将来的な拡張例

### 4.1. SendGrid を使った実際のメール送信

```typescript
// src/infrastructure/external/sendgridEmailService.ts
import sgMail from '@sendgrid/mail';
import { EmailService, EmailMessage, SendEmailError } from '@application/ports/emailService';
import { Result, ok, err } from '@shared/functional/result';

export class SendGridEmailService implements EmailService {
  constructor(apiKey: string) {
    sgMail.setApiKey(apiKey);
  }

  async send(message: EmailMessage): Promise<Result<void, SendEmailError>> {
    try {
      await sgMail.send({
        to: message.to,
        from: 'noreply@example.com',
        subject: message.subject,
        text: message.body,
      });
      return ok(undefined);
    } catch (error) {
      return err({
        type: 'EMAIL_SEND_ERROR',
        message: error.message,
      });
    }
  }
}

// 使用例
const emailService = new SendGridEmailService(process.env.SENDGRID_API_KEY);
eventBus.subscribe('ORDER_CREATED', sendOrderConfirmationEmail(emailService));
```

### 4.2. RabbitMQ を使った非同期イベント処理

```typescript
// src/infrastructure/events/rabbitMQEventBus.ts
import amqp from 'amqplib';
import { EventBus } from '@application/ports/eventBus';

export class RabbitMQEventBus implements EventBus {
  private connection: amqp.Connection;
  private channel: amqp.Channel;

  async publish<T extends { type: string }>(event: T): Promise<void> {
    const queue = `event.${event.type}`;
    await this.channel.assertQueue(queue);
    this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(event)));
  }

  subscribe<T>(eventType: string, handler: (event: T) => Promise<void>): void {
    const queue = `event.${eventType}`;
    this.channel.consume(queue, async (msg) => {
      if (msg) {
        const event = JSON.parse(msg.content.toString());
        await handler(event);
        this.channel.ack(msg);
      }
    });
  }
}
```

## 5. デバッグとモニタリング

### イベント発行のログ記録

```typescript
// ロギング付きEventBusのラッパー
class LoggingEventBus implements EventBus {
  constructor(private innerBus: EventBus) {}

  async publish<T extends { type: string }>(event: T): Promise<void> {
    console.log(`[EventBus] Publishing event: ${event.type}`, event);
    await this.innerBus.publish(event);
    console.log(`[EventBus] Event published successfully: ${event.type}`);
  }

  subscribe<T>(eventType: string, handler: (event: T) => Promise<void>): void {
    console.log(`[EventBus] Subscribing to event: ${eventType}`);
    this.innerBus.subscribe(eventType, async (event) => {
      console.log(`[EventBus] Handling event: ${eventType}`, event);
      try {
        await handler(event);
        console.log(`[EventBus] Event handled successfully: ${eventType}`);
      } catch (error) {
        console.error(`[EventBus] Error handling event: ${eventType}`, error);
        throw error;
      }
    });
  }
}

// 使用例
const baseEventBus = new InMemoryEventBus();
const eventBus = new LoggingEventBus(baseEventBus);
```

## 6. エラーハンドリング

イベントハンドラーでエラーが発生した場合、そのエラーは注文作成処理には影響しません。
これは、メール送信の失敗が注文の成功を妨げないようにするためです。

```typescript
// sendOrderConfirmationEmail.ts の実装より
const result = await emailService.send(message);

if (isErr(result)) {
  // メール送信失敗はログに記録するが、注文処理は成功とする
  console.error('メール送信に失敗しました:', result.error.message);
}
```

将来的にリトライ機構を追加する場合：

```typescript
// リトライ付きイベントハンドラー
const sendOrderConfirmationEmailWithRetry = (emailService: EmailService) =>
  async (event: OrderCreatedEvent): Promise<void> => {
    const maxRetries = 3;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      const result = await emailService.send(/* ... */);

      if (isOk(result)) {
        console.log('メール送信成功');
        return;
      }

      if (attempt < maxRetries) {
        console.log(`メール送信失敗、リトライ ${attempt}/${maxRetries}`);
        await sleep(1000 * attempt); // 指数バックオフ
      }
    }

    console.error('メール送信が最大リトライ回数に達しました');
  };
```
