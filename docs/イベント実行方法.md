# イベント駆動アーキテクチャのセットアップ例

## 1. APIサーバーでの設定例

```typescript
// src/presentation/api/server.ts

import { Hono } from 'hono';
import { InMemoryEventBus } from '@infrastructure/events/inMemoryEventBus';
import { ConsoleEmailService } from '@infrastructure/external/consoleEmailService';
import { InMemoryInventoryService } from '@infrastructure/memory/inMemoryInventoryService';
import { sendOrderConfirmationEmail } from '@application/order/sendOrderConfirmationEmail';
import { decreaseInventory } from '@application/order/decreaseInventory';
import { createOrder } from '@application/order/createOrder';
import { InMemoryOrderRepository } from '@infrastructure/memory/inMemoryOrderRepository';
import { DummyJsonProductRepository } from '@infrastructure/external/dummyJsonProductRepository';

// アプリケーション起動時の初期化
export function setupApplication() {
  // 1. インフラストラクチャ層のサービスを作成
  const eventBus = new InMemoryEventBus();
  const emailService = new ConsoleEmailService();
  const inventoryService = new InMemoryInventoryService({
    1: 100,  // 商品ID 1の在庫: 100個
    2: 50,   // 商品ID 2の在庫: 50個
  });
  const orderRepository = new InMemoryOrderRepository();
  const productRepository = new DummyJsonProductRepository();

  // 2. イベントハンドラーを登録
  eventBus.subscribe('ORDER_CREATED', sendOrderConfirmationEmail(emailService));
  eventBus.subscribe('ORDER_CREATED', decreaseInventory(inventoryService));

  // 3. ユースケースを作成
  const createOrderUseCase = createOrder(
    orderRepository,
    productRepository,
    eventBus
  );

  return {
    createOrderUseCase,
    orderRepository,
    productRepository,
    inventoryService,
  };
}

// Honoアプリケーション
const app = new Hono();

// 依存性を初期化
const { createOrderUseCase } = setupApplication();

// APIエンドポイント
app.post('/api/orders', async (c) => {
  const body = await c.req.json();

  const result = await createOrderUseCase({
    orderItems: body.orderItems,
    shippingAddress: body.shippingAddress,
    customerInfo: body.customerInfo,
  });

  if (result._tag === 'Ok') {
    return c.json(result.value, 201);
  } else {
    return c.json({ error: result.error }, 400);
  }
});

export default app;
```

## 2. テスト環境での使用例

```typescript
// テストでは、モックのEventBusを使用可能
import { describe, test, expect } from 'bun:test';

describe('注文作成の統合テスト', () => {
  test('注文作成時にメールが送信される', async () => {
    // モックEventBusでイベントをキャプチャ
    let capturedEvent = null;
    const mockEventBus = {
      publish: async (event) => {
        capturedEvent = event;
      },
      subscribe: () => {},
    };

    const useCase = createOrder(
      orderRepository,
      productRepository,
      mockEventBus
    );

    await useCase({ /* 注文データ */ });

    // イベントが発行されたことを検証
    expect(capturedEvent).not.toBeNull();
    expect(capturedEvent.type).toBe('ORDER_CREATED');
  });
});
```

## 3. イベントの実行フロー

```
┌─────────────────────────────────────────────────────────────┐
│ 1. クライアントが POST /api/orders にリクエスト             │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 2. createOrderUseCase が実行される                          │
│    - バリデーション                                          │
│    - ビジネスロジック                                        │
│    - DB保存                                                  │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 3. eventBus.publish(OrderCreatedEvent) が呼ばれる           │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 4. 登録された全てのハンドラーが並列実行される               │
│    - sendOrderConfirmationEmail（メール送信）               │
│    - decreaseInventory（在庫減少）                           │
│    - addPoints（ポイント付与 - 将来的に追加可能）           │
└─────────────────────────────────────────────────────────────┘
           ↓                                ↓
┌──────────────────────────┐  ┌──────────────────────────┐
│ 5a. メール送信            │  │ 5b. 在庫減少              │
│ （ConsoleEmailService）   │  │ （InventoryService）      │
│                          │  │                          │
│ コンソールに出力:         │  │ コンソールに出力:         │
│ === メール送信 ===       │  │ 在庫を減らしました:       │
│ To: yamada@example.com   │  │ 商品ID 1, 数量 2         │
│ Subject: 【注文確認】... │  │ 商品ID 2, 数量 3         │
└──────────────────────────┘  └──────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ 6. クライアントに注文結果を返す                             │
└─────────────────────────────────────────────────────────────┘
```

## 4. 将来的な拡張例

### 4.1. SendGrid を使った実際のメール送信

```typescript
// src/infrastructure/external/sendgridEmailService.ts
import sgMail from '@sendgrid/mail';
import { EmailService, EmailMessage, SendEmailError } from '@application/ports/emailService';
import { Result, ok, err } from '@shared/functional/result';

export class SendGridEmailService implements EmailService {
  constructor(apiKey: string) {
    sgMail.setApiKey(apiKey);
  }

  async send(message: EmailMessage): Promise<Result<void, SendEmailError>> {
    try {
      await sgMail.send({
        to: message.to,
        from: 'noreply@example.com',
        subject: message.subject,
        text: message.body,
      });
      return ok(undefined);
    } catch (error) {
      return err({
        type: 'EMAIL_SEND_ERROR',
        message: error.message,
      });
    }
  }
}

// 使用例
const emailService = new SendGridEmailService(process.env.SENDGRID_API_KEY);
eventBus.subscribe('ORDER_CREATED', sendOrderConfirmationEmail(emailService));
```

### 4.2. RabbitMQ を使った非同期イベント処理

```typescript
// src/infrastructure/events/rabbitMQEventBus.ts
import amqp from 'amqplib';
import { EventBus } from '@application/ports/eventBus';

export class RabbitMQEventBus implements EventBus {
  private connection: amqp.Connection;
  private channel: amqp.Channel;

  async publish<T extends { type: string }>(event: T): Promise<void> {
    const queue = `event.${event.type}`;
    await this.channel.assertQueue(queue);
    this.channel.sendToQueue(queue, Buffer.from(JSON.stringify(event)));
  }

  subscribe<T>(eventType: string, handler: (event: T) => Promise<void>): void {
    const queue = `event.${eventType}`;
    this.channel.consume(queue, async (msg) => {
      if (msg) {
        const event = JSON.parse(msg.content.toString());
        await handler(event);
        this.channel.ack(msg);
      }
    });
  }
}
```

## 5. デバッグとモニタリング

### イベント発行のログ記録

```typescript
// ロギング付きEventBusのラッパー
class LoggingEventBus implements EventBus {
  constructor(private innerBus: EventBus) {}

  async publish<T extends { type: string }>(event: T): Promise<void> {
    console.log(`[EventBus] Publishing event: ${event.type}`, event);
    await this.innerBus.publish(event);
    console.log(`[EventBus] Event published successfully: ${event.type}`);
  }

  subscribe<T>(eventType: string, handler: (event: T) => Promise<void>): void {
    console.log(`[EventBus] Subscribing to event: ${eventType}`);
    this.innerBus.subscribe(eventType, async (event) => {
      console.log(`[EventBus] Handling event: ${eventType}`, event);
      try {
        await handler(event);
        console.log(`[EventBus] Event handled successfully: ${eventType}`);
      } catch (error) {
        console.error(`[EventBus] Error handling event: ${eventType}`, error);
        throw error;
      }
    });
  }
}

// 使用例
const baseEventBus = new InMemoryEventBus();
const eventBus = new LoggingEventBus(baseEventBus);
```

## 6. エラーハンドリング

イベントハンドラーでエラーが発生した場合、そのエラーは注文作成処理には影響しません。
これは、メール送信の失敗が注文の成功を妨げないようにするためです。

```typescript
// sendOrderConfirmationEmail.ts の実装より
const result = await emailService.send(message);

if (isErr(result)) {
  // メール送信失敗はログに記録するが、注文処理は成功とする
  console.error('メール送信に失敗しました:', result.error.message);
}
```

将来的にリトライ機構を追加する場合：

```typescript
// リトライ付きイベントハンドラー
const sendOrderConfirmationEmailWithRetry = (emailService: EmailService) =>
  async (event: OrderCreatedEvent): Promise<void> => {
    const maxRetries = 3;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      const result = await emailService.send(/* ... */);

      if (isOk(result)) {
        console.log('メール送信成功');
        return;
      }

      if (attempt < maxRetries) {
        console.log(`メール送信失敗、リトライ ${attempt}/${maxRetries}`);
        await sleep(1000 * attempt); // 指数バックオフ
      }
    }

    console.error('メール送信が最大リトライ回数に達しました');
  };
```

## 7. 在庫管理の実装例

### 7.1. 在庫減少イベントハンドラー

注文作成時に自動的に在庫を減らします。

```typescript
// src/application/order/decreaseInventory.ts
import { InventoryService } from '@application/ports/inventoryService';
import { OrderCreatedEvent } from '@domain/order/events';

export const decreaseInventory =
  (inventoryService: InventoryService) =>
  async (event: OrderCreatedEvent): Promise<void> => {
    const { orderItems } = event.payload;

    for (const item of orderItems) {
      const result = await inventoryService.decrease(item.productId, item.quantity);

      if (isErr(result)) {
        console.error(`在庫減少に失敗: 商品ID ${item.productId}`, result.error.message);
        // TODO: 補償トランザクション（注文キャンセル、通知など）
      } else {
        console.log(`在庫を減らしました: 商品ID ${item.productId}, 数量 ${item.quantity}`);
      }
    }
  };
```

### 7.2. セットアップでの登録

```typescript
// アプリケーション起動時
const inventoryService = new InMemoryInventoryService({
  1: 100,  // 商品ID 1の初期在庫
  2: 50,   // 商品ID 2の初期在庫
});

// 在庫減少ハンドラーを登録
eventBus.subscribe('ORDER_CREATED', decreaseInventory(inventoryService));
```

### 7.3. 実行例

```
注文作成リクエスト
  商品ID 1 × 2個
  商品ID 2 × 3個
         ↓
ORDER_CREATED イベント発行
         ↓
┌──────────────────┐  ┌──────────────────┐
│ メール送信        │  │ 在庫減少          │
│ (並列実行)        │  │ (並列実行)        │
└──────────────────┘  └──────────────────┘
                           ↓
                    商品ID 1: 100 → 98
                    商品ID 2: 50  → 47
```

### 7.4. 在庫不足時の処理

在庫が不足している場合は、エラーログを出力し、将来的には補償トランザクションを実行します。

```typescript
// 在庫不足のケース
await inventoryService.decrease(1, 200);  // 在庫: 100個、要求: 200個

// コンソール出力:
// ❌ 在庫減少に失敗: 商品ID 1 在庫が不足しています（現在: 100, 必要: 200）
```

### 7.5. 補償トランザクション（Saga パターン）

在庫減少に失敗した場合の処理を追加する例：

```typescript
export const decreaseInventoryWithCompensation =
  (inventoryService: InventoryService, orderRepository: OrderRepository) =>
  async (event: OrderCreatedEvent): Promise<void> => {
    const { orderId, orderItems } = event.payload;
    const processedItems: Array<{ productId: number; quantity: number }> = [];

    for (const item of orderItems) {
      const result = await inventoryService.decrease(item.productId, item.quantity);

      if (isErr(result)) {
        console.error(`在庫減少失敗、補償トランザクション実行中...`);

        // ロールバック: すでに減らした在庫を元に戻す
        for (const processed of processedItems) {
          await inventoryService.increase(processed.productId, processed.quantity);
        }

        // 注文をキャンセル状態に更新
        await orderRepository.updateStatus(orderId, 'CANCELLED');

        console.error(`注文 ${orderId} をキャンセルしました（在庫不足のため）`);
        return;
      }

      processedItems.push({ productId: item.productId, quantity: item.quantity });
    }

    console.log(`全商品の在庫減少が完了しました`);
  };
```
