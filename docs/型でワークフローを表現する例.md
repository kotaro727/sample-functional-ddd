

### 概要
![alt text](image.png)


未検証の注文を受け取ると、検証済みの注文 or エラーを返却する関数
この関数は商品が存在することを検証する関数、アドレスが存在することを検証する関数に依存する

## コード例

```typescript
import { Result, ok, err } from '@shared/functional/result';
import { pipe } from '@shared/functional/pipe';

// ===== ドメイン型定義 =====

/**
 * 未検証の注文（生のデータ）
 */
type UnvalidatedOrder = {
  readonly orderId: string;
  readonly customerId: string;
  readonly productId: string;
  readonly quantity: number;
  readonly shippingAddress: string;
};

/**
 * 検証済みの注文（ドメインモデル）
 */
type ValidatedOrder = {
  readonly orderId: OrderId;
  readonly customerId: CustomerId;
  readonly productId: ProductId;
  readonly quantity: Quantity;
  readonly shippingAddress: ShippingAddress;
};

// 値オブジェクト（ブランド型）
type OrderId = { readonly _brand: 'OrderId'; readonly value: string };
type CustomerId = { readonly _brand: 'CustomerId'; readonly value: string };
type ProductId = { readonly _brand: 'ProductId'; readonly value: string };
type Quantity = { readonly _brand: 'Quantity'; readonly value: number };
type ShippingAddress = { readonly _brand: 'ShippingAddress'; readonly value: string };

/**
 * バリデーションエラー
 */
type ValidationError =
  | { type: 'PRODUCT_NOT_FOUND'; productId: string }
  | { type: 'ADDRESS_INVALID'; address: string }
  | { type: 'INVALID_QUANTITY'; quantity: number };

// ===== 依存関数の型定義（ポート） =====

/**
 * 商品が存在することを検証する関数の型
 */
type CheckProductExists = (
  productId: string
) => Promise<Result<ProductId, ValidationError>>;

/**
 * アドレスが存在することを検証する関数の型
 */
type CheckAddressExists = (
  address: string
) => Promise<Result<ShippingAddress, ValidationError>>;

// ===== メイン関数の型定義 =====

/**
 * 未検証の注文を検証する関数の型
 *
 * 依存関数を引数として受け取るカリー化された関数
 */
type ValidateOrder = (deps: {
  readonly checkProductExists: CheckProductExists;
  readonly checkAddressExists: CheckAddressExists;
}) => (
  order: UnvalidatedOrder
) => Promise<Result<ValidatedOrder, ValidationError>>;

// ===== 実装例（スケルトン） =====

/**
 * 注文を検証する関数
 *
 * @param deps - 依存関数を含むオブジェクト
 * @returns 未検証の注文を受け取り、検証済みの注文またはエラーを返す関数
 */
const validateOrder: ValidateOrder = (deps) => async (order) => {
  const { checkProductExists, checkAddressExists } = deps;

  // 1. 商品の存在チェック
  const productResult = await checkProductExists(order.productId);
  if (productResult._tag === 'Err') {
    return productResult;
  }

  // 2. アドレスの検証
  const addressResult = await checkAddressExists(order.shippingAddress);
  if (addressResult._tag === 'Err') {
    return addressResult;
  }

  // 3. 数量の検証
  if (order.quantity <= 0) {
    return err({
      type: 'INVALID_QUANTITY',
      quantity: order.quantity,
    });
  }

  // 4. 検証済み注文を作成
  return ok({
    orderId: { _brand: 'OrderId', value: order.orderId },
    customerId: { _brand: 'CustomerId', value: order.customerId },
    productId: productResult.value,
    quantity: { _brand: 'Quantity', value: order.quantity },
    shippingAddress: addressResult.value,
  });
};

// ===== 使用例 =====

// 依存関数の実装（モック）
const mockCheckProductExists: CheckProductExists = async (productId) => {
  // 実装: データベースやAPIで商品の存在を確認
  if (productId === 'product-123') {
    return ok({ _brand: 'ProductId', value: productId });
  }
  return err({ type: 'PRODUCT_NOT_FOUND', productId });
};

const mockCheckAddressExists: CheckAddressExists = async (address) => {
  // 実装: 住所の妥当性をチェック
  if (address && address.length > 0) {
    return ok({ _brand: 'ShippingAddress', value: address });
  }
  return err({ type: 'ADDRESS_INVALID', address });
};

// 依存関数を注入して関数を作成
const validateOrderWithDeps = validateOrder({
  checkProductExists: mockCheckProductExists,
  checkAddressExists: mockCheckAddressExists,
});

// 使用
const unvalidatedOrder: UnvalidatedOrder = {
  orderId: 'order-456',
  customerId: 'customer-789',
  productId: 'product-123',
  quantity: 5,
  shippingAddress: '東京都渋谷区...',
};

const result = await validateOrderWithDeps(unvalidatedOrder);

if (result._tag === 'Ok') {
  console.log('検証成功:', result.value);
} else {
  console.log('検証失敗:', result.error);
}

// ===== 関数合成を使ったより関数型な実装 =====

/**
 * flatMapを使った実装
 */
const validateOrderFunctional: ValidateOrder = (deps) => async (order) => {
  const { checkProductExists, checkAddressExists } = deps;

  // 数量検証のヘルパー
  const validateQuantity = (qty: number): Result<Quantity, ValidationError> => {
    if (qty <= 0) {
      return err({ type: 'INVALID_QUANTITY', quantity: qty });
    }
    return ok({ _brand: 'Quantity', value: qty });
  };

  // 商品IDの検証（非同期）
  const productResult = await checkProductExists(order.productId);
  if (productResult._tag === 'Err') return productResult;

  // アドレスの検証（非同期）
  const addressResult = await checkAddressExists(order.shippingAddress);
  if (addressResult._tag === 'Err') return addressResult;

  // 数量の検証（同期）
  const quantityResult = validateQuantity(order.quantity);
  if (quantityResult._tag === 'Err') return quantityResult;

  // すべて成功した場合、検証済み注文を作成
  return ok({
    orderId: { _brand: 'OrderId', value: order.orderId },
    customerId: { _brand: 'CustomerId', value: order.customerId },
    productId: productResult.value,
    quantity: quantityResult.value,
    shippingAddress: addressResult.value,
  });
};
```

## ポイント

### 1. **型で依存関係を表現**
```typescript
type ValidateOrder = (deps: {
  readonly checkProductExists: CheckProductExists;
  readonly checkAddressExists: CheckAddressExists;
}) => (order: UnvalidatedOrder) => Promise<Result<ValidatedOrder, ValidationError>>;
```
- カリー化で依存関数と入力を分離
- 依存関数は型で定義されたポート（インターフェース）

### 2. **値で依存関係を注入**
```typescript
const validateOrderWithDeps = validateOrder({
  checkProductExists: mockCheckProductExists,
  checkAddressExists: mockCheckAddressExists,
});
```
- 実行時に具体的な実装を注入
- テスト時は異なる実装を注入可能

### 3. **Result型で一貫したエラーハンドリング**
```typescript
type ValidationError =
  | { type: 'PRODUCT_NOT_FOUND'; productId: string }
  | { type: 'ADDRESS_INVALID'; address: string }
  | { type: 'INVALID_QUANTITY'; quantity: number };
```
- エラーの種類が型で表現される
- 例外ではなく値としてエラーを扱う

### 4. **ブランド型で型安全性を確保**
```typescript
type ProductId = { readonly _brand: 'ProductId'; readonly value: string };
type ShippingAddress = { readonly _brand: 'ShippingAddress'; readonly value: string };
```
- 単なる文字列や数値ではなく、意味のある型に昇格
- 誤った代入を防ぐ