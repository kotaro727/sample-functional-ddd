# 関数合成について

## 概要

**関数合成（Function Composition）**とは、複数の関数を組み合わせて新しい関数を作る技法です。小さく単純な関数を組み合わせることで、複雑な処理を構築します。

数学的には、関数 `f` と `g` の合成は `(f ∘ g)(x) = f(g(x))` と表されます。

## なぜ関数合成が重要なのか

### 問題：複雑な処理を一度に書くと...

```typescript
// Bad: すべてを一つの関数に詰め込む
function processUser(rawData: string): string {
  // 1. JSONパース
  const data = JSON.parse(rawData);

  // 2. バリデーション
  if (!data.email || !data.age) {
    throw new Error('Invalid data');
  }

  // 3. データ変換
  const email = data.email.toLowerCase();
  const age = Number(data.age);

  // 4. ビジネスロジック
  if (age < 18) {
    throw new Error('Too young');
  }

  // 5. フォーマット
  return `User: ${email}, Age: ${age}`;
}
```

**問題点:**
- 再利用できない
- テストしにくい
- 変更が困難
- 責任が多すぎる

### 解決：関数合成

```typescript
// Good: 小さな関数に分割
const parseJson = (raw: string) => JSON.parse(raw);
const validateData = (data: any) => { /* ... */ };
const normalizeEmail = (data: any) => ({ ...data, email: data.email.toLowerCase() });
const checkAge = (data: any) => { /* ... */ };
const formatOutput = (data: any) => `User: ${data.email}, Age: ${data.age}`;

// 関数を合成
const processUser = pipe(
  parseJson,
  validateData,
  normalizeEmail,
  checkAge,
  formatOutput
);
```

**利点:**
- 各関数が再利用可能
- 個別にテスト可能
- 変更が容易
- 単一責任の原則を守る

## 関数合成の基本パターン

### 1. シンプルな合成（compose）

```typescript
// 右から左へ実行
const compose = <A, B, C>(
  f: (b: B) => C,
  g: (a: A) => B
): ((a: A) => C) => {
  return (a: A) => f(g(a));
};

// 使用例
const add1 = (x: number) => x + 1;
const double = (x: number) => x * 2;

const add1ThenDouble = compose(double, add1);
add1ThenDouble(5);  // (5 + 1) * 2 = 12
```

### 2. パイプライン合成（pipe）

```typescript
// 左から右へ実行（より読みやすい）
const pipe = <A, B, C>(
  g: (a: A) => B,
  f: (b: B) => C
): ((a: A) => C) => {
  return (a: A) => f(g(a));
};

// 使用例
const add1ThenDouble = pipe(add1, double);
add1ThenDouble(5);  // (5 + 1) * 2 = 12
```

## このプロジェクトでの関数合成

### 1. pipe関数を使った基本的な合成

`src/shared/functional/pipe.ts`を使用:

```typescript
import { pipe } from '@shared/functional/pipe';

// 商品価格の計算
const calculatePrice = (basePrice: number) =>
  pipe(
    basePrice,
    (price) => price * 1.1,      // 税込
    (price) => Math.round(price), // 四捨五入
    (price) => `${price}円`       // フォーマット
  );

calculatePrice(1000);  // "1100円"
```

### 2. Result型との合成

`src/domain/product/product.ts`の実例:

```typescript
import { pipe } from '@shared/functional/pipe';
import { Result, map, flatMap } from '@shared/functional/result';

export const createProduct = (input: ProductInput): Result<Product, ProductError> => {
  if (input.title.trim() === '') {
    return err({ type: 'EMPTY_TITLE', message: 'タイトルは必須です' });
  }

  const productIdResult = createProductId(input.id);
  const priceResult = createPrice(input.price);

  // 関数合成で複数のバリデーションを連鎖
  return pipe(
    productIdResult,           // Result<ProductId, ProductIdError>
    flatMap((id) =>            // ProductIdが成功した場合のみ続行
      pipe(
        priceResult,           // Result<Price, PriceError>
        map((price) => ({      // Priceが成功した場合のみ続行
          id,
          title: input.title,
          price,
          description: input.description,
        }))
      )
    )
  );
};
```

**ポイント:**
- `flatMap`: Result型を返す関数を合成
- `map`: 普通の値を返す関数を合成
- エラーは自動的に伝播される

### 3. バリデーションパイプライン

値オブジェクトの作成での例:

```typescript
// src/domain/shared/valueObjects/email.ts
export const createEmail = (value: string): Result<Email, EmailError> =>
  pipe(
    value,
    // 1. 前処理
    (v) => v.trim().toLowerCase(),

    // 2. バリデーション
    (v) => {
      if (v === '') {
        return err({ type: 'EMPTY', message: 'メールアドレスが空です' });
      }
      if (!EMAIL_PATTERN.test(v)) {
        return err({ type: 'INVALID_FORMAT', message: 'メールアドレスの形式が不正です' });
      }
      return ok(v);
    },

    // 3. ドメインモデル作成
    map((v) => ({ _brand: 'Email', value: v } as Email))
  );
```

### 4. 非同期処理の合成

Application層のユースケース:

```typescript
// src/application/product/getProducts.ts
import { pipe } from '@shared/functional/pipe';

export const getProducts = (repository: ProductRepository) => async () => {
  const result = await repository.findAll();

  // 関数合成でデータ変換
  return pipe(
    result,
    map((products) =>
      products.filter((p) => p.price.value > 0)  // フィルタリング
    ),
    map((products) =>
      products.sort((a, b) => a.id.value - b.id.value)  // ソート
    )
  );
};
```

### 5. 複雑なワークフローの合成

memo.mdの注文検証の例:

```typescript
type ValidateOrder = (deps: {
  readonly checkProductExists: CheckProductExists;
  readonly checkAddressExists: CheckAddressExists;
}) => (order: UnvalidatedOrder) => Promise<Result<ValidatedOrder, ValidationError>>;

const validateOrder: ValidateOrder = (deps) => async (order) => {
  const { checkProductExists, checkAddressExists } = deps;

  // 関数合成で検証パイプラインを構築
  const productResult = await checkProductExists(order.productId);
  if (productResult._tag === 'Err') return productResult;

  const addressResult = await checkAddressExists(order.shippingAddress);
  if (addressResult._tag === 'Err') return addressResult;

  const quantityResult = validateQuantity(order.quantity);
  if (quantityResult._tag === 'Err') return quantityResult;

  // すべて成功した場合、検証済み注文を作成
  return ok({
    orderId: { _brand: 'OrderId', value: order.orderId },
    customerId: { _brand: 'CustomerId', value: order.customerId },
    productId: productResult.value,
    quantity: quantityResult.value,
    shippingAddress: addressResult.value,
  });
};
```

## 関数合成のパターン

### パターン1: 単純な値の変換

```typescript
// 数値を処理するパイプライン
const processNumber = (n: number) =>
  pipe(
    n,
    (x) => x * 2,
    (x) => x + 10,
    (x) => x.toString(),
    (x) => `結果: ${x}`
  );

processNumber(5);  // "結果: 20"
```

### パターン2: Result型を使った安全な合成

```typescript
// バリデーションチェーンを構築
const validateUser = (input: UserInput): Result<User, ValidationError> =>
  pipe(
    validateEmail(input.email),      // Result<Email, ValidationError>
    flatMap((email) =>                // emailが成功した場合のみ続行
      pipe(
        validateAge(input.age),       // Result<number, ValidationError>
        map((age) => ({ email, age })) // 両方成功したらUserを作成
      )
    )
  );
```

### パターン3: 依存性注入との組み合わせ

```typescript
// 依存性を受け取って関数を返す（カリー化）
const createOrderWorkflow = (deps: {
  validateOrder: ValidateOrder;
  calculateTotal: CalculateTotal;
  saveOrder: SaveOrder;
}) => (input: OrderInput) =>
  pipe(
    input,
    deps.validateOrder,     // 検証
    flatMap(deps.calculateTotal),  // 計算
    flatMap(deps.saveOrder)        // 保存
  );

// 依存性を注入して使用
const processOrder = createOrderWorkflow({
  validateOrder: validateOrderImpl,
  calculateTotal: calculateTotalImpl,
  saveOrder: saveOrderImpl,
});
```

### パターン4: 条件分岐を含む合成

```typescript
// 条件によって異なる処理
const processOrder = (order: Order) =>
  pipe(
    order,
    validateOrder,
    flatMap((validOrder) => {
      if (validOrder.isPriority) {
        return processPriorityOrder(validOrder);
      }
      return processNormalOrder(validOrder);
    }),
    flatMap(notifyCustomer)
  );
```

### パターン5: リストの処理

```typescript
// 商品リストの処理
const processProducts = (products: Product[]) =>
  pipe(
    products,
    (ps) => ps.filter((p) => p.price.value > 0),      // フィルタ
    (ps) => ps.map((p) => applyDiscount(p)),          // 変換
    (ps) => ps.sort((a, b) => a.price.value - b.price.value),  // ソート
    (ps) => ps.slice(0, 10)                           // 上位10件
  );
```

## 関数合成のメリット

### 1. コードの再利用性

```typescript
// 小さな関数を定義
const trim = (s: string) => s.trim();
const toLowerCase = (s: string) => s.toLowerCase();
const removeSpaces = (s: string) => s.replace(/\s+/g, '');

// 様々な組み合わせで再利用
const normalizeEmail = pipe(trim, toLowerCase);
const normalizeUsername = pipe(trim, toLowerCase, removeSpaces);
```

### 2. テストの容易さ

```typescript
// 各関数を個別にテスト
test('trim removes whitespace', () => {
  expect(trim('  hello  ')).toBe('hello');
});

test('toLowerCase converts to lowercase', () => {
  expect(toLowerCase('HELLO')).toBe('hello');
});

// 合成された関数もテスト
test('normalizeEmail works correctly', () => {
  expect(normalizeEmail('  HELLO@EXAMPLE.COM  ')).toBe('hello@example.com');
});
```

### 3. 変更の容易さ

```typescript
// 処理を追加・削除が簡単
const processData = pipe(
  validateInput,
  transformData,
  // enrichData,  // ← コメントアウトで簡単に無効化
  saveData
);
```

### 4. 読みやすさ

```typescript
// ネストより読みやすい
// Bad: ネスト
const result = saveData(enrichData(transformData(validateInput(input))));

// Good: パイプライン
const result = pipe(
  input,
  validateInput,
  transformData,
  enrichData,
  saveData
);
```

### 5. 型安全性

```typescript
// TypeScriptが各ステップの型をチェック
const result = pipe(
  "123",           // string
  parseInt,        // string => number
  (n) => n * 2,    // number => number
  (n) => `${n}円`  // number => string
);
// resultの型: string (型推論が正確！)

// 型エラーも検出される
const error = pipe(
  "123",
  parseInt,
  (n: number) => n * 2,
  (s: string) => s.toUpperCase()  // 型エラー！numberをstringとして扱えない
);
```

## 関数合成 vs 手続き的コード

### 手続き的コード

```typescript
// 手続き的なアプローチ
function processOrder(input: OrderInput): Result<Order, OrderError> {
  // ステップ1: バリデーション
  const validationResult = validateOrder(input);
  if (isErr(validationResult)) {
    return validationResult;
  }

  // ステップ2: 計算
  const calculationResult = calculateTotal(validationResult.value);
  if (isErr(calculationResult)) {
    return calculationResult;
  }

  // ステップ3: 保存
  const saveResult = saveOrder(calculationResult.value);
  if (isErr(saveResult)) {
    return saveResult;
  }

  return saveResult;
}
```

### 関数合成アプローチ

```typescript
// 関数合成アプローチ
const processOrder = (input: OrderInput): Result<Order, OrderError> =>
  pipe(
    input,
    validateOrder,
    flatMap(calculateTotal),
    flatMap(saveOrder)
  );
```

**比較:**
- 関数合成の方が簡潔
- エラーハンドリングが自動化
- データの流れが明確

## ベストプラクティス

### 1. 小さく単純な関数を作る

```typescript
// Good: 単一責任
const validateEmail = (email: string): Result<Email, EmailError> => { /* ... */ };
const validateAge = (age: number): Result<number, AgeError> => { /* ... */ };
const createUser = (email: Email, age: number): User => ({ email, age });

// Bad: 多くの責任
const validateAndCreateUser = (email: string, age: number): Result<User, Error> => {
  // バリデーションとユーザー作成を一度にやる
};
```

### 2. 純粋関数を使う

```typescript
// Good: 純粋関数（副作用なし）
const double = (x: number): number => x * 2;
const add = (a: number) => (b: number) => a + b;

// Bad: 副作用あり
let total = 0;
const addToTotal = (x: number) => {
  total += x;  // 外部状態を変更
  return total;
};
```

### 3. 型を明示する

```typescript
// Good: 型を明示
const validateEmail = (email: string): Result<Email, EmailError> => { /* ... */ };

// Bad: 型が不明瞭
const validateEmail = (email: string) => { /* ... */ };
```

### 4. pipeで処理の流れを明確にする

```typescript
// Good: 処理の流れが一目瞭然
const processOrder = pipe(
  validateOrder,
  flatMap(calculateTotal),
  flatMap(applyDiscount),
  flatMap(saveOrder),
  map(notifyCustomer)
);

// Bad: ネストが深い
const processOrder = flatMap(
  (order) => map(
    (savedOrder) => notifyCustomer(savedOrder)
  )(saveOrder(order))
)(applyDiscount(calculateTotal(validateOrder(input))));
```

### 5. エラーハンドリングを統一する

```typescript
// Good: Result型で統一
const processUser = pipe(
  validateEmail,      // Result<Email, EmailError>
  flatMap(checkAge),  // Result<number, AgeError>
  map(createUser)     // Result<User, Error>
);

// Bad: 混在
const processUser = (input: any) => {
  try {
    const email = validateEmail(input.email);  // 例外をスロー
    const age = checkAge(input.age);           // Result型を返す
    return createUser(email, age);
  } catch (e) {
    return null;  // エラー情報が失われる
  }
};
```

## よくある質問

### Q1: 関数合成は常に使うべき？

A: いいえ。単純な処理なら通常のコードで十分です。

```typescript
// シンプルなら関数合成は不要
const greet = (name: string) => `Hello, ${name}!`;

// 複雑な処理には関数合成が有効
const processOrder = pipe(
  validateOrder,
  flatMap(calculateTotal),
  flatMap(applyDiscount),
  flatMap(saveOrder)
);
```

### Q2: パフォーマンスは問題ない？

A: モダンなJavaScriptエンジンは最適化するため、ほとんど問題ありません。

### Q3: デバッグしにくい？

A: 各関数が小さいため、むしろデバッグしやすいです。

```typescript
// 途中でログを挟むことも簡単
const processOrder = pipe(
  validateOrder,
  tap((order) => console.log('Validated:', order)),  // デバッグ用
  flatMap(calculateTotal),
  tap((order) => console.log('Total:', order.total)),  // デバッグ用
  flatMap(saveOrder)
);
```

## まとめ

関数合成により:

1. **再利用性**: 小さな関数を様々な組み合わせで使える
2. **テスタビリティ**: 各関数を独立してテストできる
3. **可読性**: データの流れが一目でわかる
4. **保守性**: 変更や拡張が容易
5. **型安全性**: TypeScriptが型をチェック
6. **エラーハンドリング**: Result型で統一的に扱える

このプロジェクトでは、**pipe関数**と**Result型**を組み合わせることで、宣言的で保守性の高いコードを実現しています。

## 関連項目

- [Pipe関数について.md](./Pipe関数について.md) - pipe関数の詳細
- [カリー化について.md](./カリー化について.md) - 関数合成を支える技法
- [Result型について.md](./Result型について.md) - エラーハンドリング
- [モナドについて.md](./モナドについて.md) - 関数合成の理論的背景
- `src/shared/functional/pipe.ts` - pipe関数の実装
- `CLAUDE.md` - プロジェクト全体の関数型プログラミング方針
