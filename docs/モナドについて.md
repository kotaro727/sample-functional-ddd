# モナドについて

## 概要

**モナド（Monad）**は、関数型プログラミングにおける基本的なデザインパターンです。値をコンテキスト（文脈）で包み、そのコンテキストを保ちながら値を変換・合成するための仕組みを提供します。

難しく聞こえますが、実際には**「値に追加情報を持たせて、安全に処理を繋げる仕組み」**と考えるとわかりやすいです。

## なぜモナドが必要なのか？

### 問題：null安全でない処理

```typescript
// nullチェックが必要な処理
function getUser(id: string): User | null {
  // ...
}

function getEmail(user: User): string | null {
  return user.email;
}

function sendEmail(email: string): boolean {
  // ...
}

// 毎回nullチェックが必要で冗長
const user = getUser('123');
if (user !== null) {
  const email = getEmail(user);
  if (email !== null) {
    sendEmail(email);
  }
}
```

### 解決：モナド（Option型）

```typescript
import { Option, some, none, flatMap, map } from '@shared/functional/option';
import { pipe } from '@shared/functional/pipe';

function getUser(id: string): Option<User> {
  // ...
}

function getEmail(user: User): Option<string> {
  // ...
}

function sendEmail(email: string): boolean {
  // ...
}

// モナドを使うと簡潔に
pipe(
  getUser('123'),
  flatMap(getEmail),
  map(sendEmail)
);
// nullチェックは自動的に行われる
```

## モナドの3つの法則

モナドは以下の3つの法則を満たす必要があります：

### 1. 左単位元律（Left Identity）

```typescript
// of(a).flatMap(f) === f(a)

const value = 5;
const f = (x: number) => some(x * 2);

// 左辺
const left = flatMap(f)(some(value));

// 右辺
const right = f(value);

// 左辺と右辺は同じ結果
```

**意味**: 値をモナドに包んでから関数を適用しても、直接関数を適用しても同じ結果になる

### 2. 右単位元律（Right Identity）

```typescript
// m.flatMap(of) === m

const m = some(5);

// 左辺
const left = flatMap((x) => some(x))(m);

// 右辺
const right = m;

// 左辺と右辺は同じ
```

**意味**: モナドに対して「値をそのまま包む関数」を適用しても、元のモナドと同じ

### 3. 結合律（Associativity）

```typescript
// m.flatMap(f).flatMap(g) === m.flatMap(x => f(x).flatMap(g))

const m = some(5);
const f = (x: number) => some(x * 2);
const g = (x: number) => some(x + 10);

// 左辺
const left = pipe(
  m,
  flatMap(f),
  flatMap(g)
);

// 右辺
const right = flatMap((x) => pipe(f(x), flatMap(g)))(m);

// 左辺と右辺は同じ
```

**意味**: 関数の適用順序を変えても結果は同じ

## このプロジェクトのモナド

### 1. Result型モナド

`src/shared/functional/result.ts`:

```typescript
// Result型の定義
export type Result<T, E> = Ok<T> | Err<E>;

export interface Ok<T> {
  readonly _tag: 'Ok';
  readonly value: T;
}

export interface Err<E> {
  readonly _tag: 'Err';
  readonly error: E;
}

// モナドの基本操作

// 1. 値をモナドに包む（return/of）
export const ok = <T>(value: T): Ok<T> => ({
  _tag: 'Ok',
  value,
});

export const err = <E>(error: E): Err<E> => ({
  _tag: 'Err',
  error,
});

// 2. 値を変換する（map/fmap）
export const map = <T, U, E>(
  fn: (value: T) => U
) => (result: Result<T, E>): Result<U, E> => {
  return isOk(result) ? ok(fn(result.value)) : result;
};

// 3. モナドを返す関数を適用（flatMap/bind/chain）
export const flatMap = <T, U, E>(
  fn: (value: T) => Result<U, E>
) => (result: Result<T, E>): Result<U, E> => {
  return isOk(result) ? fn(result.value) : result;
};
```

#### Result型の使用例

```typescript
// バリデーション処理の連鎖
const validateAndProcess = (input: string): Result<number, ValidationError> =>
  pipe(
    parseNumber(input),        // Result<number, ParseError>
    flatMap(validatePositive), // Result<number, ValidationError>
    flatMap(validateRange),    // Result<number, ValidationError>
    map(multiplyByTwo)         // Result<number, ValidationError>
  );

// どこかでエラーが発生すると、自動的に伝播される
const result = validateAndProcess('abc');
// err({ type: 'PARSE_ERROR', ... })
```

### 2. Option型モナド

`src/shared/functional/option.ts`:

```typescript
// Option型の定義
export type Option<T> = Some<T> | None;

export interface Some<T> {
  readonly _tag: 'Some';
  readonly value: T;
}

export interface None {
  readonly _tag: 'None';
}

// モナドの基本操作

// 1. 値をモナドに包む
export const some = <T>(value: T): Some<T> => ({
  _tag: 'Some',
  value,
});

export const none: None = {
  _tag: 'None',
};

// 2. nullableからOptionを作成
export const fromNullable = <T>(value: T | null | undefined): Option<T> => {
  return value !== null && value !== undefined ? some(value) : none;
};

// 3. 値を変換する
export const map = <T, U>(
  fn: (value: T) => U
) => (option: Option<T>): Option<U> => {
  return isSome(option) ? some(fn(option.value)) : none;
};

// 4. モナドを返す関数を適用
export const flatMap = <T, U>(
  fn: (value: T) => Option<U>
) => (option: Option<T>): Option<U> => {
  return isSome(option) ? fn(option.value) : none;
};
```

#### Option型の使用例

```typescript
// null安全な処理の連鎖
const getUserEmail = (userId: string): Option<string> =>
  pipe(
    findUser(userId),           // Option<User>
    flatMap(getEmailFromUser),  // Option<string>
    map(normalizeEmail)         // Option<string>
  );

// 値がない場合は自動的にnoneが伝播
const result = getUserEmail('nonexistent');
// none
```

## モナドの構成要素

### 1. コンテナ型（Wrapper Type）

値を包む型です。

```typescript
// Result型はコンテナ
type Result<T, E> = Ok<T> | Err<E>;

// Option型はコンテナ
type Option<T> = Some<T> | None;
```

### 2. コンストラクタ（return/of）

値をモナドに包む関数です。

```typescript
// Result型のコンストラクタ
const ok = <T>(value: T): Ok<T> => ({ _tag: 'Ok', value });
const err = <E>(error: E): Err<E> => ({ _tag: 'Err', error });

// Option型のコンストラクタ
const some = <T>(value: T): Some<T> => ({ _tag: 'Some', value });
const none: None = { _tag: 'None' };
```

### 3. map（Functor）

値を変換する関数です。

```typescript
// 普通の値を返す関数を適用
map((n: number) => n * 2)

// Result<number> → Result<number>
pipe(
  ok(5),
  map((n) => n * 2)
);
// ok(10)

// エラーの場合はスキップ
pipe(
  err('error'),
  map((n) => n * 2)
);
// err('error')
```

### 4. flatMap（Monad）

モナドを返す関数を適用します。

```typescript
// モナドを返す関数を適用
flatMap((n: number) => validatePositive(n))

// Result<number> → Result<number>
pipe(
  ok(5),
  flatMap(validatePositive)
);
// ok(5)

pipe(
  ok(-5),
  flatMap(validatePositive)
);
// err({ type: 'NEGATIVE_NUMBER', ... })
```

## mapとflatMapの違い

### map: 普通の値を返す関数

```typescript
// 型シグネチャ
map<T, U>(fn: (value: T) => U): (m: M<T>) => M<U>

// 使用例
const double = (n: number) => n * 2;  // 普通の値を返す

pipe(
  ok(5),
  map(double)  // ok(10)
);

// ネストしてしまう例
const doubleWrapped = (n: number) => ok(n * 2);  // モナドを返す

pipe(
  ok(5),
  map(doubleWrapped)  // ok(ok(10)) ← ネストしてしまう！
);
```

### flatMap: モナドを返す関数

```typescript
// 型シグネチャ
flatMap<T, U>(fn: (value: T) => M<U>): (m: M<T>) => M<U>

// 使用例
const validatePositive = (n: number): Result<number, Error> =>
  n > 0 ? ok(n) : err({ type: 'NEGATIVE', message: '...' });

pipe(
  ok(5),
  flatMap(validatePositive)  // ok(5)
);

pipe(
  ok(-5),
  flatMap(validatePositive)  // err({ ... })
);

// flatMapはネストを平坦化する
const doubleWrapped = (n: number) => ok(n * 2);

pipe(
  ok(5),
  flatMap(doubleWrapped)  // ok(10) ← 平坦化される
);
```

## 実践例

### 例1: ユーザー登録のバリデーション

```typescript
type ValidationError =
  | { type: 'INVALID_EMAIL'; message: string }
  | { type: 'WEAK_PASSWORD'; message: string }
  | { type: 'USERNAME_TAKEN'; message: string };

// 各バリデーションはResult型を返す
const validateEmail = (email: string): Result<Email, ValidationError> => {
  // ...
};

const validatePassword = (password: string): Result<Password, ValidationError> => {
  // ...
};

const checkUsernameTaken = (username: string): Result<Username, ValidationError> => {
  // ...
};

// モナドの合成で複数のバリデーションを連鎖
const validateUserInput = (input: UserInput): Result<ValidatedUser, ValidationError> =>
  pipe(
    validateEmail(input.email),
    flatMap((email) =>
      pipe(
        validatePassword(input.password),
        flatMap((password) =>
          pipe(
            checkUsernameTaken(input.username),
            map((username) => ({
              email,
              password,
              username,
            }))
          )
        )
      )
    )
  );

// どこかでエラーが発生すると、その時点で処理が止まる
```

### 例2: 商品の作成

このプロジェクトの実際の例（`src/domain/product/product.ts`）:

```typescript
export const createProduct = (input: ProductInput): Result<Product, ProductError> => {
  if (input.title.trim() === '') {
    return err({ type: 'EMPTY_TITLE', message: 'タイトルは必須です' });
  }

  const productIdResult = createProductId(input.id);
  const priceResult = createPrice(input.price);

  // モナドの合成
  return pipe(
    productIdResult,           // Result<ProductId, ProductIdError>
    flatMap((id) =>            // ProductIdが有効な場合のみ続行
      pipe(
        priceResult,           // Result<Price, PriceError>
        map((price) => ({      // Priceが有効な場合のみ続行
          id,
          title: input.title,
          price,
          description: input.description,
        }))
      )
    )
  );
};
```

### 例3: null安全な処理

```typescript
// 従来のアプローチ（nullチェックが必要）
function getStreetName(user: User | null): string | null {
  if (user === null) return null;

  const address = user.address;
  if (address === null) return null;

  return address.street;
}

// Optionモナドを使ったアプローチ
function getStreetName(user: Option<User>): Option<string> {
  return pipe(
    user,
    flatMap((u) => u.address),    // Option<Address>
    map((addr) => addr.street)    // Option<string>
  );
}

// 使用
const streetName = pipe(
  findUser('123'),           // Option<User>
  getStreetName,             // Option<string>
  getOrElse('住所不明')      // string
);
```

## モナドのメリット

### 1. エラー処理の簡潔化

```typescript
// モナドなし: 毎回エラーチェックが必要
const result1 = step1();
if (isError(result1)) return result1;

const result2 = step2(result1);
if (isError(result2)) return result2;

const result3 = step3(result2);
if (isError(result3)) return result3;

// モナドあり: 自動的にエラーが伝播
pipe(
  step1(),
  flatMap(step2),
  flatMap(step3)
);
```

### 2. null安全性

```typescript
// モナドなし: nullチェックが必要
if (user !== null && user.profile !== null && user.profile.avatar !== null) {
  // ...
}

// モナドあり: 自動的にnullが伝播
pipe(
  fromNullable(user),
  flatMap((u) => fromNullable(u.profile)),
  flatMap((p) => fromNullable(p.avatar))
);
```

### 3. 関数合成の容易さ

```typescript
// モナドにより、小さな関数を組み合わせて複雑な処理を構築
const processOrder = pipe(
  validateOrder,
  flatMap(calculateTotal),
  flatMap(applyDiscount),
  flatMap(processPayment),
  flatMap(createInvoice),
  map(sendConfirmation)
);
```

### 4. 副作用の明示

```typescript
// 戻り値の型でエラーの可能性が明示される
function divide(a: number, b: number): Result<number, DivideError> {
  if (b === 0) {
    return err({ type: 'DIVIDE_BY_ZERO', message: '0で割ることはできません' });
  }
  return ok(a / b);
}

// 呼び出し側はエラー処理を強制される
const result = divide(10, 0);
if (isErr(result)) {
  // エラー処理
}
```

## モナドの種類（参考）

このプロジェクトで使用しているモナド以外にも、様々なモナドがあります：

### Maybe/Option モナド

```typescript
// 値があるかないかを表現
type Option<T> = Some<T> | None;

// 用途: null/undefined の安全な扱い
```

### Either/Result モナド

```typescript
// 成功または失敗を表現
type Result<T, E> = Ok<T> | Err<E>;

// 用途: エラーハンドリング
```

### Task/Promise モナド

```typescript
// 非同期処理を表現
type Task<T> = () => Promise<T>;

// 用途: 非同期処理の合成
```

### State モナド

```typescript
// 状態を持つ計算を表現
type State<S, A> = (s: S) => [A, S];

// 用途: 状態管理
```

### Reader モナド

```typescript
// 環境/設定を受け取る計算を表現
type Reader<R, A> = (r: R) => A;

// 用途: 依存性注入
```

## モナドの実装パターン

### パターン1: do記法風の実装

```typescript
// ネストを避けるためのヘルパー
function* validateUser(input: UserInput) {
  const email = yield* validateEmail(input.email);
  const password = yield* validatePassword(input.password);
  const username = yield* checkUsernameTaken(input.username);

  return { email, password, username };
}

// ジェネレーターを実行
const result = run(validateUser(input));
```

### パターン2: メソッドチェーン

```typescript
// メソッドチェーン形式（RustのResult型に近い）
ok(5)
  .map((n) => n * 2)
  .flatMap(validatePositive)
  .map((n) => `Result: ${n}`)
  .getOrElse('Error');
```

このプロジェクトでは、**カリー化された関数とpipe**を使用しています：

```typescript
// このプロジェクトのスタイル
pipe(
  ok(5),
  map((n) => n * 2),
  flatMap(validatePositive),
  map((n) => `Result: ${n}`),
  getOrElse('Error')
);
```

## よくある質問

### Q1: モナドは難しくないですか？

A: 概念は難しく見えますが、**使い方はシンプル**です：

```typescript
// 基本的な使い方
pipe(
  値,
  map(普通の関数),      // 値を変換
  flatMap(モナドを返す関数)  // 処理を連鎖
);
```

日常的に使っているPromiseも実はモナドです：

```typescript
// Promiseもモナド
promise
  .then((value) => value * 2)         // map
  .then((value) => anotherPromise())  // flatMap
```

### Q2: mapとflatMapの使い分けは？

A: 関数の戻り値で判断します：

```typescript
// 普通の値を返す → map
map((n: number) => n * 2)

// モナドを返す → flatMap
flatMap((n: number) => validatePositive(n))
```

### Q3: なぜResult型とOption型の両方が必要？

A: 用途が異なります：

```typescript
// Option: 値があるかないか（エラー情報は不要）
findUser(id);  // Option<User>

// Result: 成功か失敗か（エラー情報が必要）
validateEmail(email);  // Result<Email, ValidationError>
```

### Q4: モナド則を意識する必要は？

A: **実装する側は意識する必要がありますが、使う側は気にしなくてOK**です。

このプロジェクトのResult型とOption型は、すでにモナド則を満たすように実装されています。

## ベストプラクティス

### 1. 小さな関数に分割

```typescript
// Good: 小さな関数を組み合わせる
const validateAge = (age: number): Result<number, ValidationError> => {
  // ...
};

const createUser = (age: number): Result<User, ValidationError> => {
  // ...
};

pipe(
  validateAge(25),
  flatMap(createUser)
);

// Bad: 大きな関数
const validateAndCreateUser = (age: number): Result<User, ValidationError> => {
  // バリデーションと作成を一つの関数でやる
};
```

### 2. 型を明示する

```typescript
// Good: 戻り値の型を明示
const validateEmail = (email: string): Result<Email, EmailError> => {
  // ...
};

// Bad: 型推論に頼る
const validateEmail = (email: string) => {
  // 戻り値の型が不明瞭
};
```

### 3. エラー型を具体的に

```typescript
// Good: 具体的なエラー型
type ValidationError =
  | { type: 'INVALID_EMAIL'; email: string }
  | { type: 'WEAK_PASSWORD'; requirements: string[] };

// Bad: 汎用的すぎる
type ValidationError = string;
```

### 4. pipeで処理の流れを明確に

```typescript
// Good: pipeで処理の流れが一目瞭然
pipe(
  input,
  validateInput,
  flatMap(processData),
  flatMap(saveToDatabase),
  map(formatResponse)
);

// Bad: ネストが深い
flatMap((data) =>
  flatMap((validated) =>
    map((processed) => formatResponse(processed))(processData(validated))
  )(validateInput(input))
)(input);
```

## まとめ

モナドは：

1. **値をコンテキストで包む**: Result型ならエラー情報、Option型なら存在情報
2. **安全に処理を連鎖**: エラーやnullを自動的に伝播
3. **関数合成を容易に**: 小さな関数を組み合わせて複雑な処理を構築
4. **型安全性を提供**: コンパイル時にエラーを検出

このプロジェクトでは、**Result型とOption型**というモナドを使用することで：

- エラーハンドリングが簡潔
- null安全な処理が容易
- 関数の合成が自然
- 型安全性が向上

**難しく考えず、「値に追加情報を持たせて、安全に処理を繋げる仕組み」**として理解すれば、日常的に使えるパターンです。

## 関連項目

- [Result型について.md](./Result型について.md) - Result型モナドの詳細
- [Pipe関数について.md](./Pipe関数について.md) - モナドの合成
- [カリー化について.md](./カリー化について.md) - map/flatMapの仕組み
- `src/shared/functional/result.ts` - Result型モナドの実装
- `src/shared/functional/option.ts` - Option型モナドの実装
- `CLAUDE.md` - プロジェクト全体の関数型プログラミング方針
