# カリー化（Currying）について

## 概要

**カリー化（Currying）**とは、複数の引数を取る関数を、1つずつ引数を取る関数の連鎖に変換する技法です。関数型プログラミングにおいて、関数の再利用性と合成性を高めるための重要なテクニックです。

## 通常の関数 vs カリー化された関数

### 通常の関数（一度に全ての引数を受け取る）

```typescript
// 2つの引数を一度に受け取る
const add = (a: number, b: number): number => {
  return a + b;
};

// 使用
add(2, 3);  // 5
add(2);     // エラー！2つの引数が必要
```

### カリー化された関数（1つずつ引数を受け取る）

```typescript
// 1つずつ引数を受け取る
const addCurried = (a: number) => (b: number): number => {
  return a + b;
};

// 使用方法1: 一度に渡す
addCurried(2)(3);  // 5

// 使用方法2: 段階的に渡す（部分適用）
const add2 = addCurried(2);  // (b: number) => number
add2(3);   // 5
add2(5);   // 7
add2(10);  // 12
```

## 視覚的な理解

```typescript
// 通常の関数
add(a, b) → 結果

// カリー化された関数
addCurried(a) → 関数 → (b) → 結果
         ↓
    新しい関数が返る
```

## 部分適用とは

カリー化された関数の途中まで引数を渡すことを**部分適用（Partial Application）**と呼びます。

```typescript
const multiply = (a: number) => (b: number) => a * b;

// 部分適用: 第1引数だけを渡す
const double = multiply(2);    // (b: number) => 2 * b
const triple = multiply(3);    // (b: number) => 3 * b
const tenfold = multiply(10);  // (b: number) => 10 * b

// 使用
double(5);   // 10
triple(5);   // 15
tenfold(5);  // 50
```

## 実際の例: map関数

### 通常の関数として書いた場合

```typescript
// 通常版: 2つの引数を一度に受け取る
const mapNormal = <T, U, E>(
  fn: (value: T) => U,
  result: Result<T, E>
): Result<U, E> => {
  return isOk(result) ? ok(fn(result.value)) : result;
};

// 使用
mapNormal((n) => n * 2, ok(5));  // ok(10)

// 問題点: pipeで使いにくい
pipe(
  ok(5),
  (result) => mapNormal((n) => n * 2, result),  // 冗長な書き方が必要
  (result) => mapNormal((n) => n + 10, result)
);
```

### カリー化された関数（実際の実装）

このプロジェクトの`src/shared/functional/result.ts`での実装:

```typescript
// カリー化版: 1つずつ引数を受け取る
export const map = <T, U, E>(
  fn: (value: T) => U
) => (result: Result<T, E>): Result<U, E> => {
  return isOk(result) ? ok(fn(result.value)) : result;
};

// 使用方法1: 一度に渡す
map((n) => n * 2)(ok(5));  // ok(10)

// 使用方法2: 部分適用
const double = map((n: number) => n * 2);  // 関数が返る
double(ok(5));   // ok(10)
double(ok(10));  // ok(20)

// 使用方法3: pipeで簡潔に書ける
pipe(
  ok(5),
  map((n) => n * 2),    // 第1引数だけ渡す。第2引数はpipeが渡す
  map((n) => n + 10)    // 第1引数だけ渡す。第2引数はpipeが渡す
);
```

## なぜカリー化が便利なのか？

### 1. 部分適用による関数の再利用

```typescript
// よく使う変換を関数として保存できる
const extractName = map((user: User) => user.name);
const toUpper = map((s: string) => s.toUpperCase());
const double = map((n: number) => n * 2);

// 再利用
extractName(userResult1);
extractName(userResult2);
toUpper(nameResult1);
toUpper(nameResult2);
```

### 2. pipeとの相性が良い

```typescript
// カリー化されているので、pipeで簡潔に書ける
pipe(
  ok(5),
  map((n) => n * 2),      // 第1引数だけ渡す
  map((n) => n + 10),     // 第1引数だけ渡す
  map((n) => `${n}円`)    // 第1引数だけ渡す
);

// もしカリー化されていなかったら...
pipe(
  ok(5),
  (result) => mapNormal((n) => n * 2, result),      // 冗長
  (result) => mapNormal((n) => n + 10, result),     // 冗長
  (result) => mapNormal((n) => `${n}円`, result)    // 冗長
);
```

### 3. 関数の合成が容易になる

```typescript
// カリー化された関数は段階的に設定できる
const processUsers = (transform: (user: User) => string) => {
  const mapTransform = map(transform);  // 第1引数を固定

  return (users: Result<User[], Error>) => {
    return pipe(
      users,
      map((userList) => userList.map(transform))
    );
  };
};
```

## このプロジェクトでのカリー化の使用例

### map関数

`src/shared/functional/result.ts`での実装:

```typescript
export const map = <T, U, E>(
  fn: (value: T) => U              // 第1引数
) => (result: Result<T, E>): Result<U, E> => {  // 第2引数を受け取る関数を返す
  return isOk(result) ? ok(fn(result.value)) : result;
};

// 使い方
map(変換関数)(Result)
    ↑          ↑
  第1引数    第2引数
```

### flatMap関数

`src/shared/functional/result.ts`での実装:

```typescript
export const flatMap = <T, U, E>(
  fn: (value: T) => Result<U, E>   // 第1引数
) => (result: Result<T, E>): Result<U, E> => {  // 第2引数を受け取る関数を返す
  return isOk(result) ? fn(result.value) : result;
};

// 使い方
flatMap(Resultを返す関数)(Result)
        ↑                    ↑
      第1引数              第2引数
```

### 実際のコード例

`src/domain/product/product.ts`から:

```typescript
import { map, flatMap } from '@shared/functional/result';
import { pipe } from '@shared/functional/pipe';

export const createProduct = (input: ProductInput): Result<Product, ProductError> => {
  const productIdResult = createProductId(input.id);
  const priceResult = createPrice(input.price);

  return pipe(
    productIdResult,           // Result<ProductId, ProductIdError>
    flatMap((id) =>            // 第1引数だけ渡す。第2引数はpipeが渡す
      pipe(
        priceResult,           // Result<Price, PriceError>
        map((price) => ({      // 第1引数だけ渡す。第2引数はpipeが渡す
          id,
          title: input.title,
          price,
          description: input.description,
        }))
      )
    )
  );
};
```

#### 処理の流れ

1. **`flatMap((id) => ...)`** を実行
   - 第1引数: `(id) => ...` という関数
   - 戻り値: `(result: Result<ProductId, E>) => Result<Product, E>` という関数
   - pipeがこの関数に `productIdResult` を渡す

2. **`map((price) => ({...}))`** を実行
   - 第1引数: `(price) => ({...})` という関数
   - 戻り値: `(result: Result<Price, E>) => Result<Product, E>` という関数
   - pipeがこの関数に `priceResult` を渡す

## カリー化のパターン

### 2引数のカリー化

```typescript
// パターン
const fn = (arg1: A) => (arg2: B) => C;

// 具体例
const add = (a: number) => (b: number) => a + b;
const map = <T, U>(fn: (t: T) => U) => (list: T[]) => list.map(fn);
const concat = (a: string) => (b: string) => a + b;
```

### 3引数のカリー化

```typescript
// パターン
const fn = (arg1: A) => (arg2: B) => (arg3: C) => D;

// 具体例
const replace = (search: string) => (replacement: string) => (text: string) =>
  text.replace(search, replacement);

// 使用
const removeSpaces = replace(" ")("");
removeSpaces("hello world");  // "helloworld"

const replaceHello = replace("hello");
const replaceHelloWithHi = replaceHello("hi");
replaceHelloWithHi("hello world");  // "hi world"
```

### 4引数以上のカリー化

```typescript
// 複雑になりすぎる場合は、オブジェクトにまとめることも検討
const complexFn = (config: Config) => (data: Data) => Result;
```

## 部分適用の実践例

### 例1: よく使う変換を関数として定義

```typescript
// 部分適用で再利用可能な関数を作る
const extractUserId = map((user: User) => user.id);
const extractUserName = map((user: User) => user.name);
const extractUserEmail = map((user: User) => user.email);

// 複数の場所で使用
const userId = extractUserId(userResult);
const userName = extractUserName(userResult);
const userEmail = extractUserEmail(userResult);
```

### 例2: ドメイン固有の変換

```typescript
// バリデーション関数
const validatePositive = flatMap((n: number) =>
  n > 0 ? ok(n) : err({ type: 'NEGATIVE_NUMBER', message: '正の数である必要があります' })
);

const validateNotEmpty = flatMap((s: string) =>
  s.trim() !== '' ? ok(s) : err({ type: 'EMPTY_STRING', message: '空文字は許可されません' })
);

// 使用
pipe(
  ok(10),
  validatePositive  // 部分適用された関数をそのまま使用
);

pipe(
  ok("hello"),
  validateNotEmpty  // 部分適用された関数をそのまま使用
);
```

### 例3: 設定を持つ関数

```typescript
// データベース操作の例
const findById = <T>(repository: Repository<T>) => (id: string): Promise<Result<T, Error>> => {
  return repository.findById(id);
};

// 特定のリポジトリに部分適用
const findUserById = findById(userRepository);
const findProductById = findById(productRepository);

// 使用
await findUserById("user-123");
await findProductById("product-456");
```

## カリー化と通常の関数の使い分け

### カリー化が適している場合

- **pipeで使用する関数**: 段階的に引数を渡せると便利
- **再利用性の高い関数**: 部分適用で専用関数を作りたい場合
- **関数を返す関数**: 設定を受け取って関数を生成する場合

```typescript
// Good: pipeで使いやすい
const map = <T, U>(fn: (t: T) => U) => (list: T[]) => list.map(fn);

pipe(
  [1, 2, 3],
  map((n) => n * 2),
  map((n) => n + 1)
);
```

### 通常の関数が適している場合

- **引数が密接に関連している**: 一度に渡す方が自然な場合
- **単純なユーティリティ関数**: カリー化のメリットが少ない場合
- **既存のAPIとの互換性**: 既存のコードとの整合性を保つ場合

```typescript
// Good: 引数が密接に関連している
const calculateTotal = (price: number, quantity: number, tax: number): number => {
  return price * quantity * (1 + tax);
};

calculateTotal(100, 2, 0.1);  // 220
```

## TypeScriptでの型推論

カリー化された関数でも、TypeScriptは型を正確に推論します:

```typescript
const map = <T, U, E>(
  fn: (value: T) => U
) => (result: Result<T, E>): Result<U, E> => {
  return isOk(result) ? ok(fn(result.value)) : result;
};

// 型推論が正しく動作
const numberResult: Result<number, Error> = ok(5);
const stringResult = map((n: number) => `${n}円`)(numberResult);
// stringResultの型: Result<string, Error> ← 正確に推論される！
```

## よくある誤解

### 誤解1: 「カリー化は常にアロー関数で書く必要がある」

```typescript
// アロー関数
const add1 = (a: number) => (b: number) => a + b;

// function構文でも可能
function add2(a: number) {
  return function(b: number) {
    return a + b;
  };
}

// どちらも同じ動作
add1(2)(3);  // 5
add2(2)(3);  // 5
```

### 誤解2: 「カリー化は常に2つの引数しか扱えない」

```typescript
// 3つ以上の引数もカリー化できる
const fn = (a: number) => (b: number) => (c: number) => (d: number) =>
  a + b + c + d;

fn(1)(2)(3)(4);  // 10

// 部分適用も可能
const partial1 = fn(1);
const partial2 = partial1(2);
const partial3 = partial2(3);
partial3(4);  // 10
```

### 誤解3: 「カリー化はパフォーマンスが悪い」

```typescript
// 実際には、モダンなJavaScriptエンジンは最適化を行うため、
// パフォーマンスの差はほとんどない

// カリー化版
const curriedAdd = (a: number) => (b: number) => a + b;

// 通常版
const normalAdd = (a: number, b: number) => a + b;

// どちらも実行速度はほぼ同じ
```

## まとめ

カリー化された関数は:

1. **引数を1つずつ受け取る**: `fn(a, b)` → `fn(a)(b)`
2. **関数を返す**: 最後の引数まで渡さないと、新しい関数が返る
3. **部分適用ができる**: 途中まで引数を渡して、後で残りを渡せる
4. **pipeと相性抜群**: 引数を段階的に渡せるので、パイプライン処理に最適
5. **関数の再利用性が向上**: よく使う設定を固定した関数を簡単に作れる

### このプロジェクトでの使用パターン

```typescript
// カリー化された関数をpipeで使う基本パターン
pipe(
  value,
  map(変換関数),           // カリー化されているので第1引数だけ渡す
  flatMap(Result返す関数),  // カリー化されているので第1引数だけ渡す
  map(別の変換関数)         // カリー化されているので第1引数だけ渡す
);
```

### 利点

- **可読性**: データの流れが一目でわかる
- **再利用性**: 部分適用で専用関数を簡単に作れる
- **型安全性**: TypeScriptの型推論が正確に動作
- **合成性**: 小さな関数を組み合わせて複雑な処理を構築できる

## 関連項目

- [Pipe関数について.md](./Pipe関数について.md) - pipe関数との組み合わせ
- `src/shared/functional/result.ts` - カリー化されたmap/flatMapの実装
- `src/shared/functional/pipe.ts` - パイプライン処理
- `CLAUDE.md` - プロジェクト全体の関数型プログラミング方針
